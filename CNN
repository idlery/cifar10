import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms

batch_size = 16
epoch = 25
classes = ('plane', 'car', 'bird', 'cat', 'deer',
           'dog', 'frog', 'horse', 'ship', 'truck')
           

transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))
])

train_set = torchvision.datasets.CIFAR10(root='./data',train=True,
                                        download=false,transform=transform)
train_loader = torch.utils.data.DataLoader(train_set, batch_size=batch_size,
                                          shuffle=True, num_workers=2)
test_set = torchvision.datasets.CIFAR10(root='./data',train=False,
                                       download=false,transform=transform)
test_loader = torch.utils.data.DataLoader(test_set, batch_size=batch_size,
                                         shuffle=False,num_workers=2)


class CNN(nn.Module):
    def __init__(self):
        super(CNN,self).__init__()
        self.conv = nn.Conv2d(3,10,5)
        self.pool = nn.MaxPool2d(2,2)
        self.fc = nn.Linear(10*14*14, 10)
        # self.dropout = nn.Dropout(0.2)

    def forward(self,x):
        x = self.pool(torch.nn.functional.relu(self.conv(x)))
        
        x = x.view(-1, 10*14*14)
        # x = self.dropout(x)
        x = torch.nn.functional.relu(self.fc(x))
        # x = self.dropout(x)
        return x
        
 
cnn = CNN()
loss_f = nn.CrossEntropyLoss()

for lr in [0.001]:
    optimizer = optim.SGD(cnn.parameters(),lr=lr,momentum=0.9)

    for i in range(epoch):
        train_loss = 0
    
        for data,target in train_loader:
            optimizer.zero_grad()
            output = cnn(data)
            loss = loss_f(output,target)
            loss.backward()
            optimizer.step()
            train_loss += loss.item()*data.size(0)
    
        train_loss = train_loss/len(train_loader.dataset)
    
        print('lr:{}\t Epoch:{}\t training loss:{:.6f}'.format(lr,i+1, train_loss))
        
 def test_res():
    correct = list(0. for j in range(10))
    total = list(0. for j in range(10))
    with torch.no_grad():
        for images,labels in test_loader:
            outputs = cnn(images)
            _,predicted = torch.max(outputs.data, 1)
            c = (predicted == labels).squeeze()
            for j in range(4):
                label = labels[j]
                correct[label] += c[j].item()
                total[label] += 1
    for j in range(10):
        print('accuracy of %5s :%2d %%'%(
            classes[j], 100 * correct[j] / total[j]))
    
    return 
 
test_res()

def test_all():
    correct = 0
    total = 0
    with torch.no_grad():
        for images,labels in test_loader:
            outputs = cnn(images)
            _,predicted = torch.max(outputs.data, dim=1)
            total += labels.size(0)
            correct += (predicted==labels).sum().item()
    print('test accuracy:%d %%'%( 100 * correct / total ))
    return 100 * correct / total
